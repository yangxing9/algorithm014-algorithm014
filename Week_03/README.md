# 第三周学习笔记

## 递归（Recursion）
递归 - 循环

通过函数体来进行的循环

树的面试题解法一般都是递归 
原因：
1. 节点的定义
2. 重复性（自相似性）

### 递归模板
1. 递归终止条件
2. 处理当前层逻辑
3. 下探到下一层
4. 清理当前层
```java
public void recur(int level, int param) { 
  // terminator 递归终止条件
  if (level > MAX_LEVEL) { 
    // process result 
    return; 
  }
  // process current logic 处理当前层逻辑
  process(level, param); 
  // drill down 下探到下一层
  recur( level: level + 1, newParam); 
  // restore current status 清理当前层
}
```
### 思维要点
1. 不要人肉进行递归（最大误区）
2. 找到最近最简方法，将其拆解成可重复解决的问题（重复子问题）
3. 数学归纳法思维

### 递归与尾递归
#### 1. 递归
简单的来说递归就是一个函数直接或间接地调用自身，是为直接或间接递归。一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。
用递归需要注意以下两点：

    1. 递归就是在过程或函数里调用自身
    2. 在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口
    
递归一般用于解决三类问题：

    1. 数据的定义是按递归定义的。（Fibonacci函数，n的阶乘）
    2. 问题解法按递归实现。（回溯）
    3. 数据的结构形式是按递归定义的。（二叉树的遍历，图的搜索）

递归的缺点：

递归解题相对常用的算法如普通循环等，运行效率较低。在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，因此递归次数过多容易造成栈溢出。

#### 2. 尾递归
尾递归就是把当前的运算结果（或路径）放在参数里传给下层函数，深层函数所面对的不是越来越简单的问题，而是越来越复杂的问题，因为参数里带有前面若干步的运算路径。

尾递归的判断标准是函数运行最后一步是否调用自身，而不是是否在函数的最后一行调用自身

特点：
尾递归在普通尾调用的基础上，多出了2个特征：
    
   1. 在尾部调用的是函数自身 (Self-called)；
   2. 可通过优化，使得计算仅占用常量栈空间 (Stack Space)。


这是尾递归：
```java
function f(x) {
   if (x === 1) return 1;
   return f(x-1);
}
```
这不是尾递归：
```java
function f(x) {
   if (x === 1) return 1;
   return 1 + f(x-1);
}
```

 





